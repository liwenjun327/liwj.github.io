<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多线程——同步</title>
      <link href="2021/06/28/multithreading-02/"/>
      <url>2021/06/28/multithreading-02/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我们常讲的多线程一般就是同一进程内开辟多个线程，通过上章我们已经对线程的创建及使用有了大概了解，接下来我们就对多线程的使用进行学习及多线程存在的问题进行解决。</p><h2 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h2><p>下面例子是个简单的多线程使用，创建两个线程并启动，分别多count变量进行操作，等待两个线程都执行完后打印结果，其中CountDownLatch对象这里用来控制主线程等待两个线程都运行结束在执行。</p><p>问题：多次运行输出结果不一致。</p><p>原因：线程在获取count变量值时是先从主存中获取值然后复制值存到当前线程运行CPU的高速缓存中（每个线程可能运行在不同的CPU中），对count变量进行操作时是直接获取的高速缓存中的值运算，运算完成后在将数据刷新到主存，所以就可能存在线程1中高速缓存的值还没更新到主存中，线程2获取主存的值存到高速缓存中然后进行操作，而后导致缓存不一致问题。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main {public static int count = 0;public static void main(String[] args) {final CountDownLatch countDownLatch = new CountDownLatch(2);Thread thread1 = new Thread(new Runnable() {@Overridepublic void run() {try {for (int i = 0; i &lt; 3000; i++) {count++;}}finally{countDownLatch.countDown();}}});Thread thread2 = new Thread(new Runnable() {@Overridepublic void run() {try {for (int i = 0; i &lt; 3000; i++) {count--;}}finally{countDownLatch.countDown();}}});thread1.start();thread2.start();try {countDownLatch.await();} catch (InterruptedException e) {e.printStackTrace();}System.out.println(count);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>使用synchronized加锁解决上述问题<br>使用synchronized对lock实例加锁保证原子操作性，运行多次打印结果一致为0，注意：加锁对象必须是同一个实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main {public static int count = 0;public static void main(String[] args) {final CountDownLatch countDownLatch = new CountDownLatch(2);final Object lock = new Object();Thread thread1 = new Thread(new Runnable() {@Overridepublic void run() {try {synchronized (lock) {for (int i = 0; i &lt; 4000; i++) {count++;}}}finally{countDownLatch.countDown();}}});Thread thread2 = new Thread(new Runnable() {@Overridepublic void run() {try {synchronized (lock) {for (int i = 0; i &lt; 4000; i++) {count--;}}}finally{countDownLatch.countDown();}}});thread1.start();thread2.start();try {countDownLatch.await();} catch (InterruptedException e) {e.printStackTrace();}System.out.println(count);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>CountDownLatch（扩展）</p></li></ul><ul><li><p>说明<br>同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p></li><li><p>使用<br>创建实例时，必须指定初始的计数值，且应大于0，否则会抛出IllegalArgumentException(“count &lt; 0”)异常；<br>必须有线程显示调用await()方法，否则CountDownLatch毫无意义，方法说明：await()方法使调用该方法的线程处于等待状态，其一般是主线程调用；<br>必须显示的调用countDown()方法，最终保证计数器减为0，否则将会导致死锁，方法说明：用于使计数器减一，其一般是执行任务的线程调用；<br>当计数器减为0时调用await()方法的线程进入运行状态。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>多线程同时读写共享变量时，会造成逻辑错误，因此需要通过加锁同步，这里用的是java内部锁synchronized，后续会介绍其它显示锁。</p>]]></content>
      
      
      <categories>
          
          <category> 知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程基础</title>
      <link href="2021/06/25/multithreading-01/"/>
      <url>2021/06/25/multithreading-01/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>很久没更博客了，主要原因是觉得自己太菜了，没法把知识点更好的分析给大家，所以也是在埋头学习，打算以复习以前知识点及结合后续学习的技术作总结的方式书写博客。<br><img src="/images/multithreading/01-1.jpg"></p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>在计算机中存在多个进程，而每个进程又可以存在多个线程，比如Java中main方法就是作为一个线程启动（JVM虚拟机就是进程哦），main方法中在创建其它线程启动就是当前进程中开辟新的线程。tomcat启动也是去找（org.apache.catalina.startup.Bootstrap类）main方法当主线程启动的。<br>进程与线程的关系：进程可以包含一个或多个线程，但至少会有一个线程。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul><li><p>1.新建状态(New)：线程对象被创建后，就进入了新建状态。</p></li><li><p>2.运行状态<br>（01）就绪状态(Runnable之ready)：也被称为“可执行状态”。线程对象被创建后，调用了start()方法时,此时该线程只是获得了资格运行，还需等待调度程序调用。<br>（02）运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</p></li><li><p>3.阻塞状态(Blocked)： 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<br>(01) 等待阻塞 – 通过调用对象的wait()方法，让线程等待notify()/notifyAll()被调用。<br>(02) 同步阻塞 – 线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态。<br>(03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到其他阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p></li><li><p>4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p></li><li><p>5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</p></li><li><p>6.死亡状态(Dead)：线程执行完毕或者因异常退出了run()方法，该线程结束生命周期。<br><img src="/images/multithreading/01-2.jpg"></p></li></ul><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>通过实现Runnable接口并重写run()方法实现创建，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadMain {    public static void main(String[] args) {        Thread t = new Thread(new MyRunnable());        t.start(); // 启动新线程    }}class MyRunnable implements Runnable {    @Override    public void run() {        System.out.println("启动新线程!!");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我只讲这一种创建方式，因为其它方式最终都是实现Runnable接口的run()方法，如通过Callable抽象类实现带返回值的线程最后也需通过FutureTask构造将其转换为Runable的”方法”。</p><h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><ul><li><p>sleep()<br>主要的作用是让当前线程停止执行，把cpu让给其他线程执行，但不会释放对象锁和监控的状态，到了指定时间后线程又会自动恢复运行状态。</p></li><li><p>yield()<br>暂停当前方法，释放自己拥有的CPU，使线程进入就绪状态，进行CPU资源争夺。</p></li><li><p>join()<br>当前线程调用A线程join()方法后，需等待A线程执行完成后才会执行。</p></li><li><p>interrupted()<br>主要用于中断线程，调用该方法会改变线程中断状态，但并不会停止线程，需在run()方法中将isInterrupted()方法做轮询条件进行判断是否中断了线程，切记给出轮询中断条件避免死循环。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里只讲下一些基础使用及概念，后续会围绕实战中线程的使用进行讲解，锁的知识也会包含进去。</p>]]></content>
      
      
      <categories>
          
          <category> 知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据爬虫实战（2）</title>
      <link href="2021/04/09/htmlunit3/"/>
      <url>2021/04/09/htmlunit3/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>上章节叙述了HtmlUnit的一些基础知识点及简单运用，这章开始利用这些知识去对网页进行数据爬取。</p><h2 id="登录认证（重点）"><a href="#登录认证（重点）" class="headerlink" title="登录认证（重点）"></a>登录认证（重点）</h2><ul><li><p>普通账号密码登录<br>这种是最简单的登录方式，完全可以直接用HtmlUnit去请求登录页面填入账号、密码后点击登录按钮完成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">final WebClient webClient=new WebClient();//这里简写，可以看上一章的配置，如执行js等final HtmlPage page=webClient.getPage("登录页面地址");Thread.sleep(1000L);//如果网页加载比较慢可以多等待些时间，也可以循环通过page对象去查找登录页面指定存在的元素，直到找到，最好限制下次数HtmlInput userName = page.getHtmlElementById("userName");HtmlInput password = page.getHtmlElementById("password");if(null==userName || null==password){//查找指定元素失败return;}userName.setValueAttribute("账号");password.setValueAttribute("密码");//找到登录按钮HtmlButton button = (HtmlButton) page.getElementById("btnLogin");button.click();HtmlPage newPage = (HtmlPage)webClient.getCurrentWindow().getEnclosedPage();Thread.sleep(1000L);//这里可以做个简单的登录判断，如果登录成功了页面会跳转到首页，可以通过获取到的新页面中是否还存在指定的内容判断if(!null==newPage.getHtmlElementById("userName")){//登录失败}webClient.closeAllWindows();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>带图片验证码登录<br>这种其实也不难，只是多了个图片验证，代码跟上面大致相同，这里讲下思路，图片验证码一般都是后台生成，可以在页面上查看元素img的src请求，通过图片验证码的请求地址我们就能获取到图片了，网上有图片验证码解码工具，当然最简单的方式是肯定是人为辨别，所以为了方便，我们是可以写个性化登录页面的，像上面只有账号密码登录的这种，我们可以模拟写个相似页面，在页面中填好信息点击登录将输入的账号密码传到后台在用HtmlUnit请求页面设置值进行登录，图片验证码我们也可以直接写个img标签src改成我们后台请求，后台通过HtmlUnit去请求所需采集的网页图片验证码输入流到页面就可以展示了，通过HtmlUnit去请求是为了保持会话sessionId一致。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/****@userName 账号*@password 密码*@code    验证码*/public void codeLogin(String userName,String password,String code){WebClient webClient = getWebClient();final HtmlPage page=webClient.getPage("登录页面地址");Thread.sleep(1000L);//如果网页加载比较慢可以多等待些时间，也可以循环通过page对象去查找登录页面指定存在的元素，直到找到为止，最好限制下次数HtmlInput userName = page.getHtmlElementById("userName");HtmlInput password = page.getHtmlElementById("password");HtmlInput imgCode = page.getHtmlElementById("imgCode");if(null==userName || null==password){//查找指定元素失败return;}userName.setValueAttribute(userName);password.setValueAttribute(password);imgCode.setValueAttribute(code);//找到登录按钮HtmlButton button = (HtmlButton) page.getElementById("btnLogin");button.click();HtmlPage newPage = (HtmlPage)webClient.getCurrentWindow().getEnclosedPage();Thread.sleep(1000L);//这里可以做个简单的登录判断，如果登录成功了页面会跳转到首页，可以通过获取到的新页面中是否还存在指定的内容判断if(!null==newPage.getHtmlElementById("userName")){//登录失败}webClient.closeAllWindows();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>短信验证码登录<br>这种应该是最难的了，只能人为去验证登录，思路跟图片验证码差不多，自定义个性化页面，这里注意了，发送短信是需要点击才能发送且是要填写好账号密码才能成功，所以这里在自定义页面时需要注意给发送短信按钮自定义js事件，发送时检查是否填写好了账号密码，然后将账号密码传到后台赋值并触发发送短信按钮</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/****发送短信验证码***/public void sendSMS(String userName,String password){WebClient webClient = getWebClient();final HtmlPage page=webClient.getPage("登录页面地址");Thread.sleep(1000L);//如果网页加载比较慢可以多等待些时间，也可以循环通过page对象去查找登录页面指定存在的元素，直到找到为止，最好限制下次数HtmlInput userName = page.getHtmlElementById("userName");HtmlInput password = page.getHtmlElementById("password");if(null==userName || null==password){//查找指定元素失败return;}userName.setValueAttribute(userName);password.setValueAttribute(password);//找到发送短信按钮HtmlButton button = (HtmlButton) page.getElementById("sendSms");button.click();Thread.sleep(1000L);//webClient.closeAllWindows(); 这里不要在关闭了，webClient可以保存起来用于等下登录用webClientMap.put("key",webClient);//保存浏览器客户端}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送短信验证码后手机上查收并填入自定义个性化页面短信验证码输入框中，在点击登录，后台获取到刚才的webClient继续将短信验证码值设置进去，在触发登录按钮事件完成登录</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/****短信验证码登录***/public void smsLogin(String smsCodeValue){//拿到上面保存的浏览器客户端WebClient webClient = webClientMap.get("key");//获取上次保存了的浏览器客户端当前页面final HtmlPage page = webClient.getCurrentWindow().getEnclosedPage();HtmlInput smsCode = page.getHtmlElementById("smsCode");if(null==smsCode){//查找指定元素失败return;}smsCode.setValueAttribute(smsCodeValue);//找到登录按钮HtmlButton button = (HtmlButton) page.getElementById("btnLogin");button.click();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="保存会话"><a href="#保存会话" class="headerlink" title="保存会话"></a>保存会话</h2><p>上面图片验证码例子只是一个简写的思路，实际中我们是需要先用HtmlUnit去访问登录页面保存好浏览器客户端会话，然后在打开个性化页面去刷新图片验证码，保持浏览器会话一致，不然后执行Htmlunit访问登录页面图片验证码肯定是不对应的。</p><p>像一般的网页隔一段时间不操作就会会话过期导致需要重新登录，所以我们可以在登录时保存客户端会话，然后通过定时任务去定时请求页面（如登录后的首页），这样就可以一直保存会话了。</p><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>数据爬虫其实难点就是认证，认证成功后我们就可以直接用HtmlUnit去请求获取数据的接口，或者拿到展示页面的dom进行解析，推荐找到前后端交互的数据接口，通过HtmlUnit去请求接口获取响应内容，根据返回内容进行解析入库</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void getData(){WebClient webClient = webClientMap.get("key");//请求实体WebRequest request = new WebRequest();//这里request参数省略，根据接口请自己定义请求方式、请求参数、请求编码、请求Url等Page page = webClient.getPage(request);//请求响应状态码int statusCode = page.getWebResponse().getStatusCode();//获取响应内容有2种//1.获取流InputStream inputStream = page.getWebResponse().getContentAsStream();//2.获取流String str = page.getWebResponse().getContentAsString(Charset.forName("utf-8"));//通过获取的内容进行解析（如json格式数据、xml格式数据等）/***如果请求的是文件下载，WebClient.setAttachmentHandler()此处可以重写AttachmentHandler接口处理响应内容*获取流将文件保存到本地*然后解析文件*///入库等操作}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>上面都是简单的例子及思路，可能写的不是很详细，需对HtmlUnit进行了解及知道简单的使用才能更好理解，有些较为复杂的验证也还是需要花费大量时间去攻破的，博主工作中也是有遇到过一些棘手的，如请求头中携带Token，Htmlunit是没法自动实现添加的，所以需要我们在HtmlUnit请求时拦截下来进行设置（HttpWebConnection这个类中可以实现），要细说估计不是三言两语能讲完的了，如有疑惑可以通过添加qq或者邮箱询问。</p>]]></content>
      
      
      <categories>
          
          <category> 数据爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HtmlUnit </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github访问失败解决</title>
      <link href="2021/03/29/github-solves-the-wall/"/>
      <url>2021/03/29/github-solves-the-wall/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>国内大部分地区访问github.com及gitHub Pages相关个人博客出现访问失败，经查验在解析getHub相关域名会被指向到127.0.0.1上去。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li><p>方案一<br>修改电脑路径C:\windows\system32\drivers\etc下面的hosts文件<br><img src="/images/github-solves-the-wall-1.jpg" alt="hosts配置"><br>修改完成后cmd命令窗口执行下”ipconfig /flushdns”即可。</p></li><li><p>方案二（推荐使用）<br>相比较方案一不需要频繁修改hosts文件指定域名解析ip，只需修改本地DNS服务器地址，下面我修改成阿里的。<br>更改网络适配器<br><img src="/images/github-solves-the-wall-2.png" alt="更改网络适配器"><br>找到需要修改的网络鼠标右键属性并在列表中找到Internet协议双击<br><img src="/images/github-solves-the-wall-3.jpg" alt="找到Internet协议"><br>修改DNS服务器地址<br><img src="/images/github-solves-the-wall-4.jpg" alt="修改DNS服务器地址"></p></li></ul><p>以上两种均可，推荐使用方案二,手机同理也可以修改DNS为手动并添加223.5.5.5实现访问。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据爬虫实战（1）</title>
      <link href="2021/03/27/htmlunit2/"/>
      <url>2021/03/27/htmlunit2/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>上章介绍了常用的爬虫技术，本章以HtmlUnit为主要爬取技术手段开始讲解实战中如何运用，有不懂之处可邮箱询问。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>添加Htmlunit相关jar包，<a href="https://mvnrepository.com/artifact/net.sourceforge.htmlunit/htmlunit">Maven地址</a>  ，<a href="https://sourceforge.net/projects/htmlunit/files/htmlunit/">jar包下载地址</a>,注意2.43版本开始需要jdk8+支持。</p><h2 id="HtmlUnit入门"><a href="#HtmlUnit入门" class="headerlink" title="HtmlUnit入门"></a>HtmlUnit入门</h2><p>数据抓取面临的就是如何获取到想要的内容，这里可以是网页内容也可以是某个请求返回的内容，先看一个简单抓取HtmlUnit官网页面内容例子:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">final WebClient webClient=new WebClient();final HtmlPage page=webClient.getPage("http://htmlunit.sourceforge.net");System.out.println(page.asText());webClient.closeAllWindows();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只要4行代码就可以获取HtmlUnit官网页面内容，是不是很简单，但请不要这么觉得，分析一下，上述例子抓取目标是公开的静态页面，但要是遇到需身份认证后才可访问的页面或页面内容是js生成的要如何处理了，不要着急，后续会逐一讲解。</p><p>上章节说到HtmlUnit可以模仿常规浏览器，这里我将之拆分为三块，浏览器客户端（WebClient）、浏览器窗口（WebWindow）、页面（Page），即使用WebClient创建浏览器，通过webClient.getPage()打开浏览器窗口及获取页面，首先我们先明白之间关系。</p><ul><li><strong>WebClient</strong><br>Web客户端实例，起始点，此类线程不安全，常用构造函数WebClient(BrowserVersion browserVersion)，指定浏览器创建客户端，详细请查阅<a href="https://htmlunit.sourceforge.io/apidocs/com/gargoylesoftware/htmlunit/WebClient.html">API</a> ，此类提供了浏览器客户端的相关配置，如是否支持cookie、是否执行JavaScript等，下面放上我的WebClient配置供参考<pre class="line-numbers language-none"><code class="language-none">private void init(BrowserVersion browserVersion){this.browser = new WebClient(browserVersion);if(this.webSiteId != null &amp;&amp; this.webSiteId.intValue() != 0L){//根据业务需求添加cookiethis.browser.setCookieManager(CookieManagerHolder.getCookieManager(webSiteId));}browser.getOptions().setCssEnabled(false);//是否加载css,无界面所以不加载browser.getOptions().setTimeout(10*60*1000);browser.getOptions().setJavaScriptEnabled(true);//是否加载js,建议开启browser.getCookieManager().setCookiesEnabled(true);//支持cookiebrowser.getOptions().setThrowExceptionOnScriptError(false);  //解析js出错时不抛异常browser.getOptions().setThrowExceptionOnFailingStatusCode(false);browser.getOptions().setUseInsecureSSL(true); //支持请求https形式browser.getCache().setMaxSize(100);//默认好像是40，这里批缓存文件，此处根据实际情况设置，因为有些网站缓存会导致一些意想不到的情况从而导致认证失败//页面alter弹出框只打印日志browser.setAlertHandler(new AlertHandler() {//private static final long serialVersionUID = -4252009088789246842L;@Overridepublic void handleAlert(com.gargoylesoftware.htmlunit.Page page, String message) {logger.info(page.toString()+"{},alert:{}", page.getUrl(), message);}});//确认框处理器,默认点击"确认",若有不同的作法请调用registerConfirmHandler设置browser.setConfirmHandler(new GobalConfirmHandler());  //GobalConfirmHandler此处实现了ConfirmHandler接口，重写handleConfirm方法，返回true为确认反之取消。/**设置附件下载处理器，此处GobalAttachmentHandler实现了AttachmentHandler接口，重写handleAttachment方法,*在通过此方法入参Page对象获取流将之保存，代码：page.getWebResponse().getContentAsStream()获取流*/browser.setAttachmentHandler(new GobalAttachmentHandler(this));//执行ajax控制器，可打印日志用于调试等操作browser.setAjaxController(new NicelyResynchronizingAjaxController(){private static final long serialVersionUID = -360189032618131935L;@Overridepublic boolean processSynchron(HtmlPage page, com.gargoylesoftware.htmlunit.WebRequest settings,boolean async) {logger.info("ajax request url:{}", settings.getUrl());logger.info("ajax{},请求Body:{}",settings.getUrl(),settings.getRequestBody());List&lt;NameValuePair&gt; params = settings.getRequestParameters();if(params != null &amp;&amp; !params.isEmpty()){logger.info("ajax request parameters is ....begin...");for(NameValuePair p : params){logger.info("{}={}", p.getName(), p.getValue());}logger.info("ajax request parameters is ....end...");}else{logger.info("ajax request url:{} not parameters", settings.getUrl());}return super.processSynchron(page, settings, async);}});//新增浏览器窗口监听，可打印日志查看HtmlUnit执行时打开、修改的窗口信息browser.addWebWindowListener(new WebWindowListener() {@Overridepublic void webWindowOpened(WebWindowEvent event) {logger.info("浏览器:{},打开了窗口:{},URL:{},其TopWindow为:{},总共开启了窗口数:{}",getName(),event.getWebWindow().getName(),event.getWebWindow().getEnclosedPage() != null ? event.getWebWindow().getEnclosedPage().getUrl():"",(event.getWebWindow().getTopWindow() == null ? "无":event.getWebWindow().getTopWindow().getName()),browser.getWebWindows().size());}@Overridepublic void webWindowContentChanged(WebWindowEvent event) {logger.info("浏览器:{},修改了窗口:{},URL:{},其TopWindow为:{},总共开启了窗口数:{}",getName(),event.getWebWindow().getName(),event.getWebWindow().getEnclosedPage() != null ? event.getWebWindow().getEnclosedPage().getUrl():"",(event.getWebWindow().getTopWindow() == null ? "无":event.getWebWindow().getTopWindow().getName()),browser.getWebWindows().size());}@Overridepublic void webWindowClosed(WebWindowEvent event) {logger.info("浏览器:{},关闭了窗口:{},URL:{},其TopWindow为:{},总共开启了窗口数:{}",getName(),event.getWebWindow().getName(),event.getWebWindow().getEnclosedPage() != null ? event.getWebWindow().getEnclosedPage().getUrl():"",(event.getWebWindow().getTopWindow() == null ? "无":event.getWebWindow().getTopWindow().getName()),browser.getWebWindows().size());}});//HtmlUnit执行请求都会进入这，可打印日志用于查看调试，ajax请求到这后参数会消失所有最好还是在上面ajax控制器中也打印日志HttpWebConnection conn = new HttpWebConnection(browser){@Overridepublic com.gargoylesoftware.htmlunit.WebResponse getResponse(com.gargoylesoftware.htmlunit.WebRequest request) throws IOException {com.gargoylesoftware.htmlunit.WebResponse response = super.getResponse(request);logger.info("htmlunit{}请求{},Request Method:{},Response Code:{}",(isAjaxRequest(request)?" ajax":""),request.getUrl(),request.getHttpMethod(), response.getStatusCode());if(Configuration.isRequestLogParams()){logRequestParams(request);}if(Configuration.isRequestLogHeaders()){logRequestHeaders(request);}if(Configuration.isRequestLogCookies()){logRequestCookies(request);}if(!patternRespHandlers.isEmpty()){String path = request.getUrl().getPath();for(Map.Entry&lt;String, RegexPathResponseHandler&gt; e : patternRespHandlers.entrySet()){if(path.matches(e.getKey())){e.getValue().handle(request, response);}}}return response;}protected boolean isAjaxRequest(com.gargoylesoftware.htmlunit.WebRequest request){if(request.getAdditionalHeaders() == null || request.getAdditionalHeaders().isEmpty())return false;return "XMLHttpRequest".equalsIgnoreCase(request.getAdditionalHeaders().get("X-Requested-With"));}protected void logRequestParams(com.gargoylesoftware.htmlunit.WebRequest request){logger.info("请求:{},请求Body:", request.getUrl(), (request.getRequestBody() == null ? "" : request.getRequestBody()));List&lt;NameValuePair&gt; params = request.getRequestParameters();if(params != null &amp;&amp; !params.isEmpty()){logger.info("请求:{},请求参数如下:",request.getUrl());for(NameValuePair p : params){logger.info(p.getName()+"="+p.getValue());}}else{logger.info("请求:{},请求参数:无", request.getUrl());}}protected void logRequestHeaders(com.gargoylesoftware.htmlunit.WebRequest request){Map&lt;String,String&gt; headers = request.getAdditionalHeaders();if(headers != null &amp;&amp; !headers.isEmpty()){logger.info("请求:{},请求头如下:",request.getUrl());for(Map.Entry&lt;String, String&gt; h : headers.entrySet()){logger.info(h.getKey()+"="+h.getValue());}}else{logger.info("请求:{},请求头:无",request.getUrl());}}protected void logRequestCookies(com.gargoylesoftware.htmlunit.WebRequest request){if(browser.getCookieManager() == null){return;}Set&lt;com.gargoylesoftware.htmlunit.util.Cookie&gt; cookies = browser.getCookieManager().getCookies();if(cookies != null &amp;&amp; !cookies.isEmpty()){logger.info("请求:{},Cookies如下:",request.getUrl());for(com.gargoylesoftware.htmlunit.util.Cookie ck : cookies){logger.info(ck.toString());}}else{logger.info("请求:{},Cookies:无",request.getUrl());}}};browser.setWebConnection(conn);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p><strong>HtmlPage（Page实现类）</strong><br>HTML页面的表示形式对象，通过WebClient.getPage方法获取，此类主要提供了不同的方法来访问页面的内容及触发元素事件等。<br>主要获取Html元素方法可通过指定id获取、指定tag名称查询、xPath方式查询<br>说明：下面page为HtmlPage对象</p></li><li><p>通过指定id获取<br>HtmlElement dom = page.getHtmlElementById(“id”);</p></li><li><p>指定tag名称查询<br>DomNodeList<domelement>  aList = page.getElementsByTagName(“a”);</domelement></p></li><li><p>xPath方式查询<br>HtmlInput fhStartTimeInput = page.getFirstByXPath(“//div[@widgetname=’发货开始时间’]/div[1]/input”);<br>xPath较为复杂，详细可查阅<a href="https://www.w3school.com.cn/xpath/xpath_syntax.asp">文档</a></p></li></ul><p>HtmlUnit还提供了指定from名称获取的方式，这里就不叙述了，有兴趣的可以查阅资料</p><ul><li><strong>页面元素操作</strong><br>操作元素很简单，在上面我们获取到了元素，只需通过获取到的元素操作即可。<pre class="line-numbers language-java" data-language="java"><code class="language-java">//获取Input标签元素并设置value值，如下HtmlInput htmlInput = page.getFirstByXPath("//input[@id="userName"]");htmlInput.setValueAttribute("值");//获取button按钮触发点击事件HtmlButton button = (HtmlButton) page.getElementById("btnLogin");button.click();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>通过上面利用获取页面标签元素进行操作，我们就可以模拟出在浏览器界面操作效果。</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>暂时就先说到这吧，至于采集页面数据及登录认证等就放在后面章节吧，先将基础掌握才能支撑起我们后续的数据采集。</p>]]></content>
      
      
      <categories>
          
          <category> 数据爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HtmlUnit </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络数据爬虫简介</title>
      <link href="2021/03/25/htmlunit1/"/>
      <url>2021/03/25/htmlunit1/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>最近工作上都忙于采集各系统的数据，所以也是在数据爬虫方面进行了学习，今天也是抽空出来记录下。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>爬虫（程序）</strong>、<strong>自动化</strong>、<strong>抓取数据</strong>。<br>通俗的讲就是利用程序自动化获取想要的数据进行存储。</p><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><p>现在比较常见的有Jsoup、HtmlUnit、Httpclient等，以下简单介绍下。</p><ul><li><p>Jsoup<br>jsoup是一个用于处理真实HTML的Java库。它提供了一个非常方便的API，用于提取和操作数据，使用最好的DOM，CSS和类似jquery的方法。<br>优点：轻量级框架，静态页面Dom解析异常简单,操作也是时候简单，知道Jquery的使用基本就能快速上手。<br>缺点：只能解析静态网页，无法支持页面js。</p></li><li><p>HtmlUnit（强烈推荐）<br>HtmlUnit是一款java的无界面浏览器程序库，它为HTML文档建模，并提供一个API，使您可以调用页面，填写表单，单击链接等，就像在“常规”浏览器中一样。<br>它具有相当不错的JavaScript支持（正在不断改进），并且甚至可以与非常复杂的AJAX库一起工作，根据所使用的配置来模拟Chrome，Firefox或Internet Explorer。<br>优点：能执行JavaScript、AJAX解析，模仿点击页面操作完成一系列指令。<br>缺点：选择器有点难用，JavaScript容易报错。</p></li><li><p>Httpclient<br>HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包。<br>在爬虫方面简单粗暴的直接利用url，各种请求获取数据，上面介绍的两种方式也是对Httpclient进行了封装。<br>优点：简单粗暴，直接通过http形式获取数据<br>缺点：没有解析页面，在面对cookie认证的请求时需先获取到认证cookie，无法像htmlunit模拟执行页面操作（htmlunit模仿登录操作，登录成功后会保存认证的cookie、session等）。</p></li></ul><p>以上几种各有优缺点，推荐一起使用，Htmlunit&gt;Jsoup&gt;Httpclient。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本章暂介绍博主工作上用到的相关爬虫，若有更好的也请各位指教，后续章节会讲解博主在实战中是如何使用的及一些小技巧。<br>注：后续相关爬虫技术均采用的Java语言，至于前些年大火的Python爬虫就不介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 数据爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HtmlUnit </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的一年新的开始</title>
      <link href="2021/03/15/one-title/"/>
      <url>2021/03/15/one-title/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>这算是第一篇博客吧，之前都是把学习上、工作上的问题记录在有道云笔记上，没有想过分享出来，现准备以博客的形式记录。</p><h2 id="2021年新的开始"><a href="#2021年新的开始" class="headerlink" title="2021年新的开始"></a>2021年新的开始</h2><p>2018年11月13日入职了第一家公司，做的是智慧工地web及APP，刚入职场秉着积极向上的心态认真工作，不到半年就迎来了加薪，本以为发展前景一片大好，随之而来的是高层的分歧，导致入职时谈好的半年一加薪及各项福利没有落实下来，初入职场的我也是想着多干些日子积累经验及技术。</p><p>好景不长，2020年的新冠疫情的爆发，导致公司高层分歧加剧，2020年3月5日公司开会（3月1日返的工），公司开发部大部分需转型到前线去接触业务，就是变相裁员，被逼无奈只能离职重新找工作，同批离职的有7个人，也就是这段时期让我认知到了个人能力的重要，离职后的两个星期，我和一同事相继收到了offer，期间的苦可能只有经历了疫情期间找工作的才知道吧，其它几名同事面试机会寥寥无几及疫情期间招工要求普遍提高，后也是相继回了老家或继续艰辛求职。</p><p>直到今日入职第二家公司也要一年了，抽了些时间搭了个人博客准备记录日常，新的一年新的开始。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li>在好的平台也不是自己的，学到的才是自己的。</li><li>想到了什么事情就立马做，不然过段时间可能就不了了之了。</li><li>改变不了以前就改变现在。</li><li>看技术时看个整体知道是干嘛的就行，<strong>动手非常重要</strong>，实践出真理。</li><li>想学一门技术时不要犹犹豫豫，不要考虑学了有没有用，学了就是自己的，遇到困难也不要气馁，解决了印象更深。</li></ul><p>暂时就说到这吧，在此送给各位一些话，也是给自己的。</p>]]></content>
      
      
      <categories>
          
          <category> 自我感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自省 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
